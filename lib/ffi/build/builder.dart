import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';

// class FfiConverter extends GeneratorForAnnotation<void> {
//   @override
//   generateForAnnotatedElement(element, _) {
//     if (element is MethodElement) {
//       var originalCode = element.computeNode()!.toSource();

//       var methodName = element.name;
//       var params = element.parameters.map((p) => p.toSource()).join(', ');

//       var newCode = '''
// ${originalCode.substring(0, originalCode.indexOf('{') + 1)}
//   _lib.$methodName($params);
// }''';

//       return newCode;
//     }
//   }
// }

class FFIBuilder implements Builder {
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Get the `LibraryElement` for the primary input.
    var entryLib = await buildStep.inputLibrary;

    // Resolves all libraries reachable from the primary input.
    var resolver = buildStep.resolver;
    var visibleLibraries = await resolver.libraries.length;

    var info = buildStep.inputId.changeExtension('.g.dart');

    // Prepare a buffer to write the new content into
    final buffer = StringBuffer();

    buffer.writeln("""// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'package:flutter_filament/ffi/ffi_web_js/generated_bindings_js.dart';
import 'package:wasm_ffi/wasm_ffi.dart' as ffi;
import 'dart:js_interop';

late NativeLibrary _lib;""");

    // Iterate over every top-level element in the entry library
    for (var unit in entryLib.units) {
      for (var element in unit.classes) {
        if (element.name == 'NativeLibrary') {
          for (var method in element.methods) {
            // We're only interested in abstract methods to generate their implementations
            final returnType =
                method.returnType.getDisplayString(withNullability: false);
            final methodName = method.name;
            final parameterList = method.parameters.map((param) {
              final type = param.type.getDisplayString(withNullability: false);
              return '$type ${param.name}';
            }).join(', ');

            final arguments =
                method.parameters.map((param) => param.name).join(', ');

            // Write the method with the body calling _lib's corresponding method
            buffer.writeln('''
$returnType $methodName($parameterList) {
  ${returnType != "void" ? "return" : ""} _lib.$methodName($arguments);
}
''');
          }
        }
      }
    }
    await buildStep.writeAsString(info, buffer.toString());
  }

  @override
  Map<String, List<String>> get buildExtensions {
    return const {
      '.dart': ['.g.dart'],
    };
  }
}

Builder ffiBuilder(BuilderOptions options) => FFIBuilder();

// Builder ffiConverter(BuilderOptions options) =>
//     LibraryBuilder(FfiConverter(), generatedExtension: '.g.dart');
